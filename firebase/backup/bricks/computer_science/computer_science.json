{"subject":{"value":"Computer Science","type":"string"},"prep":{"value":"<iframe width=\"100%\" height=\"315\" src=\"https://www.youtube.com/embed/RUCkd4puis4\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","type":"string"},"creator":{"value":"Lindsay MacVean","type":"string"},"type":{"value":1,"type":"number"},"title":{"value":"Applied Merkle Trees","type":"string"},"summary":{"value":"<p>Hashing can be used as a 'checksum' technology, to verify a single piece of (potentially large) data, by performing a known hashing algorithm on the content and confirming that the same answer is returned as the original hash. However this is not the most important thing about hashing. As we can see in the questions, it is possible to use hashes to create a leaf and branch structure called a 'Merkle tree', this can be used to verify not just a single piece of data but actually verify multiple pieces of data at the same time, as well as data objects in a tree or subtree.</p>  <p>It is important to understand that we used a square root function to emulate a hashing algorithm. However this is not a true hashing algorithm because it is inefficient for large values and does not provide a fixed length hash, instead we need to add additional steps to the function to curtail or add preceding zeroes in order to make the final hash value consistent. We also need to consider that there is a higher chance of a collision with such a simple function as a square root. It is very easy to imagine two very large numeric values that when hashed and curtailed, end up with the same value and therefore negate the uniqueness of the hash. More advanced hashing algorithms like SHA-256 use a 64 hex string which means there are a total of approximately 1x10<sup>77</sup> values (which is getting close to the total number of atoms in the universe), this dramatically decreases the chances of collision where two files have the same hash.</p>  <p>Using a tree structure we created a hierarchy of files akin to a file system. This could be used as an addressing structure, for example by using a series of hashes to reference: first the high level tree, then the sub tree path, and finally the data object that is a 'leaf' on that tree. There are other ways to address data that may be more efficient for retrieval, however hashing is one of the most efficient ways to detect if a change has been made to any of the 'leaves' or files in the tree<p>  <p>We went a step further and took each change to a set of files and hashed the new version of tree with the preceding hash in order to create a Merkle tree of Merkle Trees, or what some people might describe as a simple blockchain. This is the basis for the success of Git version control. Git is a distributed version control that means anyone can take a copy of the Merkle tree of Merkle Trees (or 'commit' history of a code repository as it is called), make changes and then share those changes with others, the blockchain makes it is incredibly easy to detect a difference between two 'commit' histories, and even narrow down quickly to the file in the hierarchy that is different. The difference between our blockchain and the Blockchain used in modern crypto-currencies like Bitcoin is the additional protocols to define limits on values, as a money system each file represents a users wallet and has to have authentication, and a balance to limit people from spending money they do not have.</p>  <p>The other difference with a Blockchain such as Bitcoin, is as a system to resolve multiple competing versions of history. For example Joe says he paid Bob, but Bob says he never got paid. This is outside the scope of this brick but a fascinating area for further reading.</p>","type":"string"},"brief":{"value":"Merkle Trees have been used in many technologies such as Bitcoin and Git version Control. In this brick we will be using 'square root' as a contrived hashing function in order to emulate more complex hash functions like SHA-1 or SHA-256, we will then put this into a merkle tree and finally try extending this into a delta compression chain. The goal is to see why we use this technology to detect changes to both decrease storage requirements and quickly detect changes in a file system or version history.","type":"string"},"pallet":{"value":{"_referencePath":{"segments":["pallets","demopallet"],"projectId":"learning-fortress","databaseId":"(default)"}},"type":"documentReference"}}